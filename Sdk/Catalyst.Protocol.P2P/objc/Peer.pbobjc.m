// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Peer.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Peer.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PeerRoot

@implementation PeerRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - PeerRoot_FileDescriptor

static GPBFileDescriptor *PeerRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"Catalyst.Protocol.Peer"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - PeerProtocol

@implementation PeerProtocol


typedef struct PeerProtocol__storage_ {
  uint32_t _has_storage_[1];
} PeerProtocol__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerProtocol class]
                                     rootClass:[PeerRoot class]
                                          file:PeerRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PeerProtocol__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerProtocol_PingRequest

@implementation PeerProtocol_PingRequest

@dynamic ping;

typedef struct PeerProtocol_PingRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *ping;
} PeerProtocol_PingRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ping",
        .dataTypeSpecific.className = NULL,
        .number = PeerProtocol_PingRequest_FieldNumber_Ping,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerProtocol_PingRequest__storage_, ping),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerProtocol_PingRequest class]
                                     rootClass:[PeerRoot class]
                                          file:PeerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerProtocol_PingRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PeerProtocol)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerProtocol_PongResponse

@implementation PeerProtocol_PongResponse

@dynamic pong;

typedef struct PeerProtocol_PongResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *pong;
} PeerProtocol_PongResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pong",
        .dataTypeSpecific.className = NULL,
        .number = PeerProtocol_PongResponse_FieldNumber_Pong,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerProtocol_PongResponse__storage_, pong),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerProtocol_PongResponse class]
                                     rootClass:[PeerRoot class]
                                          file:PeerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerProtocol_PongResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PeerProtocol)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerProtocol_ACK

@implementation PeerProtocol_ACK

@dynamic ack;

typedef struct PeerProtocol_ACK__storage_ {
  uint32_t _has_storage_[1];
  NSData *ack;
} PeerProtocol_ACK__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ack",
        .dataTypeSpecific.className = NULL,
        .number = PeerProtocol_ACK_FieldNumber_Ack,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerProtocol_ACK__storage_, ack),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerProtocol_ACK class]
                                     rootClass:[PeerRoot class]
                                          file:PeerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerProtocol_ACK__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PeerProtocol)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerProtocol_NACK

@implementation PeerProtocol_NACK

@dynamic nack;

typedef struct PeerProtocol_NACK__storage_ {
  uint32_t _has_storage_[1];
  NSData *nack;
} PeerProtocol_NACK__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nack",
        .dataTypeSpecific.className = NULL,
        .number = PeerProtocol_NACK_FieldNumber_Nack,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerProtocol_NACK__storage_, nack),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerProtocol_NACK class]
                                     rootClass:[PeerRoot class]
                                          file:PeerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerProtocol_NACK__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PeerProtocol)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerProtocol_PeerInfoRequest

@implementation PeerProtocol_PeerInfoRequest

@dynamic ping;

typedef struct PeerProtocol_PeerInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *ping;
} PeerProtocol_PeerInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ping",
        .dataTypeSpecific.className = NULL,
        .number = PeerProtocol_PeerInfoRequest_FieldNumber_Ping,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerProtocol_PeerInfoRequest__storage_, ping),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerProtocol_PeerInfoRequest class]
                                     rootClass:[PeerRoot class]
                                          file:PeerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerProtocol_PeerInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PeerProtocol)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerProtocol_PeerInfoResponse

@implementation PeerProtocol_PeerInfoResponse

@dynamic pong;

typedef struct PeerProtocol_PeerInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *pong;
} PeerProtocol_PeerInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pong",
        .dataTypeSpecific.className = NULL,
        .number = PeerProtocol_PeerInfoResponse_FieldNumber_Pong,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerProtocol_PeerInfoResponse__storage_, pong),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerProtocol_PeerInfoResponse class]
                                     rootClass:[PeerRoot class]
                                          file:PeerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerProtocol_PeerInfoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PeerProtocol)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerProtocol_PeerNeighborsRequest

@implementation PeerProtocol_PeerNeighborsRequest

@dynamic ping;

typedef struct PeerProtocol_PeerNeighborsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *ping;
} PeerProtocol_PeerNeighborsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ping",
        .dataTypeSpecific.className = NULL,
        .number = PeerProtocol_PeerNeighborsRequest_FieldNumber_Ping,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerProtocol_PeerNeighborsRequest__storage_, ping),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerProtocol_PeerNeighborsRequest class]
                                     rootClass:[PeerRoot class]
                                          file:PeerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerProtocol_PeerNeighborsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PeerProtocol)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerProtocol_PeerNeighborsResponse

@implementation PeerProtocol_PeerNeighborsResponse

@dynamic pong;

typedef struct PeerProtocol_PeerNeighborsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *pong;
} PeerProtocol_PeerNeighborsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pong",
        .dataTypeSpecific.className = NULL,
        .number = PeerProtocol_PeerNeighborsResponse_FieldNumber_Pong,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerProtocol_PeerNeighborsResponse__storage_, pong),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerProtocol_PeerNeighborsResponse class]
                                     rootClass:[PeerRoot class]
                                          file:PeerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerProtocol_PeerNeighborsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PeerProtocol)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerProtocol_ChallengeRequest

@implementation PeerProtocol_ChallengeRequest

@dynamic nonce;

typedef struct PeerProtocol_ChallengeRequest__storage_ {
  uint32_t _has_storage_[1];
  int64_t nonce;
} PeerProtocol_ChallengeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = PeerProtocol_ChallengeRequest_FieldNumber_Nonce,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerProtocol_ChallengeRequest__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerProtocol_ChallengeRequest class]
                                     rootClass:[PeerRoot class]
                                          file:PeerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerProtocol_ChallengeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PeerProtocol)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerProtocol_ChallengeResponse

@implementation PeerProtocol_ChallengeResponse

@dynamic signedNonce;
@dynamic publicKey;

typedef struct PeerProtocol_ChallengeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *signedNonce;
  NSString *publicKey;
} PeerProtocol_ChallengeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signedNonce",
        .dataTypeSpecific.className = NULL,
        .number = PeerProtocol_ChallengeResponse_FieldNumber_SignedNonce,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerProtocol_ChallengeResponse__storage_, signedNonce),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = PeerProtocol_ChallengeResponse_FieldNumber_PublicKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PeerProtocol_ChallengeResponse__storage_, publicKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerProtocol_ChallengeResponse class]
                                     rootClass:[PeerRoot class]
                                          file:PeerRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerProtocol_ChallengeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\013\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PeerProtocol)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
