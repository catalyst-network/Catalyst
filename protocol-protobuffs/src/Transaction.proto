/**
* Copyright (c) 2019 Catalyst Network
*
* This file is part of Catalyst.Network.Protocol.Protobuffs <https://github.com/catalyst-network/protocol-protobuffs>
*
* Catalyst.Network.Protocol.Protobuffs is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 2 of the License, or
* (at your option) any later version.
* 
* Catalyst.Network.Protocol.Protobuffs is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with Catalyst.Network.Protocol.Protobuffs If not, see <https://www.gnu.org/licenses/>.
*/

syntax = "proto3";

option java_multiple_files = true;

import "google/protobuf/timestamp.proto";

package Catalyst.Protocol.Transaction;

enum TransactionType {
	NORMAL = 0;
	CONFIDENTIAL = 1;
}

/**
 * Transaction
 *
 * TransactionType: 0 for non-confidential transaction, 1 for confidential transaction
 * TimeStamp:
 * TransactionFees: 8 bytes, clear text, fees * 10^12 - always positive
 * LockTime: 32 bits
 * STEntries: 0 field for confidential transaction
 * CFEntries: 0 field for non-confidential transaction
 * Signature: 64 bytes
 * EntryRangeProof: 0 field for non-confidential transaction
 * Init: 0 field for smart contract deployment
 * Data: 0 field for smart contract calls
 * From: PubKey: 32 bytes, (255 bits or 256 with last bit to 0) public key (account address derived from the public key)
 */
message TransactionBroadcast {
	TransactionType TransactionType = 1;
    google.protobuf.Timestamp TimeStamp = 2;
    uint64 TransactionFees = 3;
    uint64 LockTime = 4;
    repeated STTransactionEntry STEntries = 5;
    repeated CFTransactionEntry CFEntries = 6;
    bytes Signature = 7; 
	bytes Init = 9;
	bytes Data = 10;
	bytes From = 11;
}

/**
 * STTransactionEntry
 *
 * PubKey: 32 bytes, (255 bits or 256 with last bit to 0) public key (account address derived from the public key)
 * Amount: max 8 bytes (positive or negative)
 */
message STTransactionEntry {
    bytes PubKey = 1;
    uint64 Amount = 2;
}
 
/**
 * CFTransactionEntry
 *
 * PubKey: 32 bytes, account address derived from the public key
 * PedersenCommitment: 32 bytes
 */
message CFTransactionEntry { 
    bytes PubKey = 1;
    bytes PedersenCommit = 2;
    EntryRangeProof EntryRangeProofs = 3;
}

/**
 * EntryRangeProof
 * BulletProof-based range proof. See https://eprint.iacr.org/2017/1066.pdf for references to equations below.
 * Total byte size is (9+2k)*32, where k = log_2(n*m), m is number of aggregates in proof, (2^n)-1 is upper range of values.
 * V: m * 32 bytes, value commitment (eq. 36) 
 * A: 32 bytes, bit commitment (eq. 48)
 * S: 32 bytes, per bit blinding factor commitment (eq. 48)
 * T1: 32 bytes, poly commitment (eq. 54)
 * T2: 32 bytes, poly commitment (eq. 54)
 * TAU: 32 bytes, proof of share (eq. 63)
 * MU: 32 bytes, proof of share (eq. 63)
 * L: k * 32 bytes, aggregated vector polynomial (eq. 63)
 * R: k * 32 bytes, aggregated vector polynomial (eq. 63)
 * APrime0: 32 bytes (eq. 63)
 * BPrime0: 32 bytes (eq. 63)
 */
message EntryRangeProof {
    repeated bytes V = 1;
    bytes A = 2;
    bytes S = 3;
    bytes T1 = 4;
    bytes T2 = 5;
    bytes TAU = 6;
    bytes MU = 7;
    repeated bytes L = 8;
    repeated bytes R = 9;
    bytes APrime0 = 10;
    bytes BPrime0 = 11;
    bytes t = 12;
} 

/**
 * CoinbaseEntry
 *
 * Version: For now only one verison. Workers would be paid in plain tx.
 * Amount: max 8 bytes (always positive).
 */
message CoinbaseEntry {
    uint32 Version = 1;
    bytes PubKey = 2;
    uint64 Amount = 3;
}
